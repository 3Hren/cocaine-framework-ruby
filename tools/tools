#!/usr/local/bin/ruby

require 'thor'
require 'json'

require 'rainbow/ext/string'

require_relative '../lib/cocaine'

module CocaineTools
  module App
    def self.stage(prompt)
      puts "[  --  ] #{prompt} ..."
      result, magic = yield
      puts "\e[A\r[#{'  OK  '.color :green}] #{prompt}#{result ? '    ' : ": #{magic.to_s.color :green}"}"
      return result
    rescue Exception => err
      puts "\e[A\r[#{' FAIL '.color :red}] #{prompt}: #{err.to_s.color :red}"
      raise err
    end

    def self.upload(path, name=nil)
      manifest = stage "Locating and reading manifest from '#{path}'" do
        MessagePack.pack JSON.parse File.read File.join path, 'manifest.json'
      end

      name ||= File.basename path

      tmpdir = Dir.mktmpdir 'cocaine-app-archive'
      tmpfile = File.join(tmpdir, "#{name}.tar.gz")
      archive = stage "Creating archive from '#{path}'" do
        begin
          `tar -czf #{tmpfile} -C #{path} .`
          MessagePack.pack File.read tmpfile
        ensure
          FileUtils.remove_entry_secure tmpdir
        end
      end

      storage = stage 'Connecting to the Cocaine' do
        Cocaine::Service.new :storage
      end

      stage 'Uploading manifest' do
        storage.write :manifests, name, manifest, [:app]
      end

      stage 'Uploading archive' do
        storage.write :apps, name, archive, [:app]
      end
    end

    # noinspection RubyResolve
    def self.restart(app, profile)
      node = stage 'Connecting to the Cocaine' do
        Cocaine::Service.new :node
      end

      stage "Stopping application '#{app}'" do
        _, rx = node.pause_app [app]
        [nil, rx.get]
      end

      stage "Starting application '#{app}' with profile '#{profile}'" do
        _, rx = node.start_app({ app => profile })
        [nil, rx.get]
      end
    end
  end
end

class App < Thor
  desc 'list', 'apps list'
  def list
    storage = Cocaine::Service.new :storage
    _, rx = storage.find :manifests, [:app]
    LOG.info "Apps: #{rx.get}"
  end

  desc 'upload PATH', 'upload application from PATH'
  def upload(path=Dir.pwd)
    CocaineTools::App::upload path
  rescue
    exit(1)
  end

  desc 'restart APP PROFILE', 'restart APP with PROFILE'
  def restart(app, profile)
    CocaineTools::App::restart app, profile
  end
end

class Profile < Thor
  desc 'list', 'profiles list'
  def list
    storage = Cocaine::Service.new :storage
    _, rx = storage.find :profiles, [:profile]
    LOG.info "Profiles: #{rx.get}"
  end

  desc 'edit', ''
  def edit(name)
    storage = Cocaine::Service.new :storage
    # _, rx = storage.read :profiles, name
    # id, payload = rx.get
    # content = MessagePack.unpack payload[0]
    # LOG.debug content
    #
    # file = Tempfile.new('profile')
    begin
      # file.write content
      # file.close
      # system(ENV['EDITOR'] || 'vim' + ' ' + file.path)
      # file.open
      content = {
          :isolate => {
              :args => {
                  :spool => '/Users/esafronov/cocaine/var/spool/cocaine'
              },
              :type => 'process'
          },
          'log-output' => true
      }
      content = MessagePack.pack content #file.read
      storage.write :profiles, name, content
    ensure
      # file.unlink
    end
  end
end

class CrashLog < Thor
  desc 'view', ''
  def view(name, timestamp)
    storage = Cocaine::Service.new :storage
    _, rx = storage.find :crashlogs, [name]

    LOG.info "Profiles: #{rx.get}"
  end
end

class CocaineToolsCLI < Thor
  desc 'app SUBCOMMAND', 'Application specific tools'
  subcommand :app, App

  desc 'profile SUBCOMMAND', 'Profile specific tools'
  subcommand :profile, Profile
end

# Suppress internal loggers.
Celluloid.logger = nil
Cocaine::LOG.level = Logger::ERROR

CocaineToolsCLI.start(ARGV)